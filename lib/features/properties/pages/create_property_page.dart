import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'dart:io';
import 'package:image_picker/image_picker.dart';
import '../../../../shared/services/property_service.dart';
import '../../../../shared/services/gallery_service.dart';
import '../../../../shared/services/cep_service.dart';
import '../../../../shared/services/ai_service.dart';
import '../../../../shared/widgets/app_scaffold.dart';
import '../../../../shared/widgets/custom_text_field.dart';
import '../../../../shared/widgets/custom_button.dart';
import '../../../../shared/widgets/skeleton_box.dart';
import '../../../../shared/widgets/shimmer_image.dart';
import '../../../../core/theme/app_colors.dart';
import '../../../../core/theme/theme_helpers.dart';
import '../../../../shared/utils/input_formatters.dart';
import '../../../../shared/utils/masks.dart';

/// Página de criação/edição de propriedade com formulário multi-etapas
class CreatePropertyPage extends StatefulWidget {
  final String? propertyId; // Se fornecido, é edição

  const CreatePropertyPage({super.key, this.propertyId});

  @override
  State<CreatePropertyPage> createState() => _CreatePropertyPageState();
}

class _CreatePropertyPageState extends State<CreatePropertyPage> {
  final PageController _pageController = PageController();
  final PropertyService _propertyService = PropertyService.instance;

  int _currentStep = 0;
  final int _totalSteps = 7; // Adicionada etapa de revisão

  // Controllers do formulário
  final _formKey = GlobalKey<FormState>();

  // Etapa 1: Informações Básicas
  final _titleController = TextEditingController();
  final _descriptionController = TextEditingController();
  PropertyType _selectedType = PropertyType.house;
  PropertyStatus _selectedStatus = PropertyStatus.draft;

  // Etapa 2: Localização
  final _streetController = TextEditingController();
  final _numberController = TextEditingController();
  final _complementController = TextEditingController();
  final _neighborhoodController = TextEditingController();
  final _cityController = TextEditingController();
  final _stateController = TextEditingController();
  final _zipCodeController = TextEditingController();

  // Etapa 3: Características
  final _totalAreaController = TextEditingController();
  final _builtAreaController = TextEditingController();
  final _bedroomsController = TextEditingController();
  final _bathroomsController = TextEditingController();
  final _parkingSpacesController = TextEditingController();
  final List<String> _selectedFeatures = [];

  // Etapa 4: Valores
  final _salePriceController = TextEditingController();
  final _rentPriceController = TextEditingController();
  final _condominiumFeeController = TextEditingController();
  final _iptuController = TextEditingController();
  bool _acceptsNegotiation = false;
  final _minSalePriceController = TextEditingController();
  final _minRentPriceController = TextEditingController();
  String? _offerBelowMinSaleAction;
  String? _offerBelowMinRentAction;

  // Etapa 5: Galeria
  final List<File> _selectedImages = [];
  final List<GalleryImage> _uploadedImages = [];
  final ImagePicker _imagePicker = ImagePicker();
  bool _isUploadingImages = false;

  // Etapa 6: Clientes e Proprietário
  final List<String> _selectedClientIds = []; // TODO: Buscar clientes reais

  // Serviços
  final GalleryService _galleryService = GalleryService.instance;
  final CepService _cepService = CepService.instance;
  final AiService _aiService = AiService.instance;

  // IA
  List<GeneratedDescription> _generatedVariants = [];
  bool _isGeneratingDescription = false;
  bool _autoGenerateOnReview = true; // Auto-gerar na revisão por padrão
  bool _hasAutoGeneratedOnReview = false; // Flag para evitar múltiplas gerações

  // Proprietário (obrigatórios)
  final _ownerNameController = TextEditingController();
  final _ownerEmailController = TextEditingController();
  final _ownerPhoneController = TextEditingController();
  final _ownerDocumentController = TextEditingController();
  final _ownerAddressController = TextEditingController();

  bool _isLoading = false;
  bool _isLoadingProperty = false;

  @override
  void initState() {
    super.initState();
    if (widget.propertyId != null) {
      _loadProperty();
    }

    // Adicionar listeners para revalidar quando os campos mudarem
    _titleController.addListener(_onFieldChanged);
    _descriptionController.addListener(_onFieldChanged);
    _streetController.addListener(_onFieldChanged);
    _numberController.addListener(_onFieldChanged);
    _neighborhoodController.addListener(_onFieldChanged);
    _cityController.addListener(_onFieldChanged);
    _stateController.addListener(_onFieldChanged);
    _zipCodeController.addListener(_onFieldChanged);
    _zipCodeController.addListener(_onCepChanged);
    _totalAreaController.addListener(_onFieldChanged);
    _builtAreaController.addListener(_onFieldChanged);
    _ownerNameController.addListener(_onFieldChanged);
    _ownerEmailController.addListener(_onFieldChanged);
    _ownerPhoneController.addListener(_onFieldChanged);
    _ownerDocumentController.addListener(_onFieldChanged);
    _ownerAddressController.addListener(_onFieldChanged);
  }

  void _onFieldChanged() {
    // Revalidar quando os campos mudarem para atualizar o estado do botão
    if (mounted) {
      setState(() {
        // Apenas força rebuild para atualizar o botão
      });
    }
  }

  void _onCepChanged() {
    // Buscar CEP automaticamente quando tiver 8 dígitos
    final cep = _zipCodeController.text.replaceAll(RegExp(r'[^0-9]'), '');
    if (cep.length == 8) {
      // Aguardar um pouco para o usuário terminar de digitar
      Future.delayed(const Duration(milliseconds: 500), () {
        if (mounted &&
            _zipCodeController.text.replaceAll(RegExp(r'[^0-9]'), '').length ==
                8) {
          _searchCep();
        }
      });
    }
  }

  @override
  void dispose() {
    // Remover listeners
    _titleController.removeListener(_onFieldChanged);
    _descriptionController.removeListener(_onFieldChanged);
    _streetController.removeListener(_onFieldChanged);
    _numberController.removeListener(_onFieldChanged);
    _neighborhoodController.removeListener(_onFieldChanged);
    _cityController.removeListener(_onFieldChanged);
    _stateController.removeListener(_onFieldChanged);
    _zipCodeController.removeListener(_onFieldChanged);
    _zipCodeController.removeListener(_onCepChanged);
    _totalAreaController.removeListener(_onFieldChanged);
    _builtAreaController.removeListener(_onFieldChanged);
    _ownerNameController.removeListener(_onFieldChanged);
    _ownerEmailController.removeListener(_onFieldChanged);
    _ownerPhoneController.removeListener(_onFieldChanged);
    _ownerDocumentController.removeListener(_onFieldChanged);
    _ownerAddressController.removeListener(_onFieldChanged);

    _pageController.dispose();
    _titleController.dispose();
    _descriptionController.dispose();
    _streetController.dispose();
    _numberController.dispose();
    _complementController.dispose();
    _neighborhoodController.dispose();
    _cityController.dispose();
    _stateController.dispose();
    _zipCodeController.dispose();
    _totalAreaController.dispose();
    _builtAreaController.dispose();
    _bedroomsController.dispose();
    _bathroomsController.dispose();
    _parkingSpacesController.dispose();
    _salePriceController.dispose();
    _rentPriceController.dispose();
    _condominiumFeeController.dispose();
    _iptuController.dispose();
    _minSalePriceController.dispose();
    _minRentPriceController.dispose();
    _ownerNameController.dispose();
    _ownerEmailController.dispose();
    _ownerPhoneController.dispose();
    _ownerDocumentController.dispose();
    _ownerAddressController.dispose();
    super.dispose();
  }

  Future<void> _loadProperty() async {
    if (widget.propertyId == null) return;

    setState(() {
      _isLoadingProperty = true;
    });

    try {
      final response = await _propertyService.getPropertyById(
        widget.propertyId!,
      );

      if (mounted && response.success && response.data != null) {
        final property = response.data!;
        _populateForm(property);
      }
    } catch (e) {
      debugPrint('Erro ao carregar propriedade: $e');
    } finally {
      if (mounted) {
        setState(() {
          _isLoadingProperty = false;
        });
      }
    }
  }

  void _populateForm(Property property) {
    _titleController.text = property.title;
    _descriptionController.text = property.description;
    _selectedType = property.type;
    _selectedStatus = property.status;

    _streetController.text = property.street;
    _numberController.text = property.number;
    _complementController.text = property.complement ?? '';
    _neighborhoodController.text = property.neighborhood;
    _cityController.text = property.city;
    _stateController.text = property.state;
    _zipCodeController.text = property.zipCode;

    _totalAreaController.text = property.totalArea > 0
        ? property.totalArea.toString()
        : '';
    _builtAreaController.text = property.builtArea?.toString() ?? '';
    _bedroomsController.text = property.bedrooms?.toString() ?? '';
    _bathroomsController.text = property.bathrooms?.toString() ?? '';
    _parkingSpacesController.text = property.parkingSpaces?.toString() ?? '';
    _selectedFeatures.clear();
    _selectedFeatures.addAll(property.features);

    _salePriceController.text = property.salePrice != null
        ? Masks.money((property.salePrice! * 100).toStringAsFixed(0))
        : '';
    _rentPriceController.text = property.rentPrice != null
        ? Masks.money((property.rentPrice! * 100).toStringAsFixed(0))
        : '';
    _condominiumFeeController.text = property.condominiumFee != null
        ? Masks.money((property.condominiumFee! * 100).toStringAsFixed(0))
        : '';
    _iptuController.text = property.iptu != null
        ? Masks.money((property.iptu! * 100).toStringAsFixed(0))
        : '';
    _acceptsNegotiation = property.acceptsNegotiation ?? false;
    _minSalePriceController.text = property.minSalePrice != null
        ? Masks.money((property.minSalePrice! * 100).toStringAsFixed(0))
        : '';
    _minRentPriceController.text = property.minRentPrice != null
        ? Masks.money((property.minRentPrice! * 100).toStringAsFixed(0))
        : '';
    _offerBelowMinSaleAction = property.offerBelowMinSaleAction;
    _offerBelowMinRentAction = property.offerBelowMinRentAction;

    // Proprietário
    if (property.owner != null) {
      _ownerNameController.text = property.owner!.name ?? '';
      _ownerEmailController.text = property.owner!.email ?? '';
      _ownerPhoneController.text = property.owner!.phone ?? '';
      _ownerDocumentController.text = property.owner!.document ?? '';
      _ownerAddressController.text = property.owner!.address ?? '';
    }

    if (property.images != null) {
      _uploadedImages.clear();
      // Converter PropertyImage para GalleryImage (aproximação)
      // Em produção, você pode buscar as imagens completas via GalleryService
    }
  }

  Future<void> _searchCep() async {
    final cep = _zipCodeController.text.replaceAll(RegExp(r'[^0-9]'), '');
    if (cep.length != 8) {
      ScaffoldMessenger.of(
        context,
      ).showSnackBar(const SnackBar(content: Text('CEP deve ter 8 dígitos')));
      return;
    }

    try {
      final address = await _cepService.searchCep(cep);
      if (address != null && mounted) {
        setState(() {
          _streetController.text = address.street ?? '';
          _neighborhoodController.text = address.neighborhood ?? '';
          _cityController.text = address.city ?? '';
          _stateController.text = address.state ?? '';
        });
        ScaffoldMessenger.of(
          context,
        ).showSnackBar(const SnackBar(content: Text('CEP encontrado!')));
      } else if (mounted) {
        ScaffoldMessenger.of(
          context,
        ).showSnackBar(const SnackBar(content: Text('CEP não encontrado')));
      }
    } catch (e) {
      debugPrint('Erro ao buscar CEP: $e');
      if (mounted) {
        ScaffoldMessenger.of(
          context,
        ).showSnackBar(const SnackBar(content: Text('Erro ao buscar CEP')));
      }
    }
  }

  Future<void> _pickImages() async {
    // Mostrar opções: tirar foto ou selecionar da galeria
    final option = await showModalBottomSheet<ImageSource>(
      context: context,
      shape: const RoundedRectangleBorder(
        borderRadius: BorderRadius.vertical(top: Radius.circular(20)),
      ),
      builder: (context) => Container(
        padding: const EdgeInsets.all(24),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Container(
              width: 40,
              height: 4,
              margin: const EdgeInsets.only(bottom: 24),
              decoration: BoxDecoration(
                color: ThemeHelpers.borderLightColor(context),
                borderRadius: BorderRadius.circular(2),
              ),
            ),
            ListTile(
              leading: const Icon(Icons.camera_alt),
              title: const Text('Tirar Foto'),
              onTap: () => Navigator.pop(context, ImageSource.camera),
            ),
            ListTile(
              leading: const Icon(Icons.photo_library),
              title: const Text('Selecionar da Galeria'),
              onTap: () => Navigator.pop(context, ImageSource.gallery),
            ),
            const SizedBox(height: 8),
            TextButton(
              onPressed: () => Navigator.pop(context),
              child: const Text('Cancelar'),
            ),
          ],
        ),
      ),
    );

    if (option == null) return;

    try {
      if (option == ImageSource.camera) {
        // Tirar foto
        final XFile? photo = await _imagePicker.pickImage(
          source: ImageSource.camera,
          imageQuality: 85,
        );
        if (photo != null) {
          setState(() {
            _selectedImages.add(File(photo.path));
          });
        }
      } else {
        // Selecionar múltiplas imagens da galeria
        final List<XFile> images = await _imagePicker.pickMultiImage(
          imageQuality: 85,
        );
        if (images.isNotEmpty) {
          setState(() {
            _selectedImages.addAll(images.map((xFile) => File(xFile.path)));
          });
        }
      }
    } catch (e) {
      debugPrint('Erro ao selecionar imagens: $e');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Erro ao selecionar imagens: $e'),
            backgroundColor: AppColors.status.error,
          ),
        );
      }
    }
  }

  Future<void> _uploadImages(String propertyId) async {
    if (_selectedImages.isEmpty) return;

    setState(() {
      _isUploadingImages = true;
    });

    try {
      final response = await _galleryService.uploadImages(
        propertyId: propertyId,
        files: _selectedImages,
      );

      if (mounted) {
        if (response.success && response.data != null) {
          setState(() {
            _uploadedImages.addAll(response.data!);
            _selectedImages.clear();
          });
        } else {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text(
                response.message ?? 'Erro ao fazer upload das imagens',
              ),
              backgroundColor: AppColors.status.error,
            ),
          );
        }
      }
    } catch (e) {
      debugPrint('Erro ao fazer upload: $e');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Erro ao fazer upload das imagens')),
        );
      }
    } finally {
      if (mounted) {
        setState(() {
          _isUploadingImages = false;
        });
      }
    }
  }

  Future<void> _generateDescription() async {
    if (_totalAreaController.text.trim().isEmpty ||
        _cityController.text.trim().isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Preencha pelo menos: tipo, cidade e área total'),
        ),
      );
      return;
    }

    setState(() {
      _isGeneratingDescription = true;
    });

    try {
      final request = GenerateDescriptionRequest(
        type: _selectedType.value,
        city: _cityController.text.trim(),
        neighborhood: _neighborhoodController.text.trim().isEmpty
            ? null
            : _neighborhoodController.text.trim(),
        totalArea: double.tryParse(_totalAreaController.text) ?? 0.0,
        builtArea: _builtAreaController.text.trim().isEmpty
            ? null
            : double.tryParse(_builtAreaController.text),
        bedrooms: _bedroomsController.text.trim().isEmpty
            ? null
            : int.tryParse(_bedroomsController.text),
        bathrooms: _bathroomsController.text.trim().isEmpty
            ? null
            : int.tryParse(_bathroomsController.text),
        parkingSpaces: _parkingSpacesController.text.trim().isEmpty
            ? null
            : int.tryParse(_parkingSpacesController.text),
        salePrice: _salePriceController.text.trim().isEmpty
            ? null
            : Masks.unmaskMoney(_salePriceController.text) / 100.0,
        rentPrice: _rentPriceController.text.trim().isEmpty
            ? null
            : Masks.unmaskMoney(_rentPriceController.text) / 100.0,
        condominiumFee: _condominiumFeeController.text.trim().isEmpty
            ? null
            : Masks.unmaskMoney(_condominiumFeeController.text) / 100.0,
        iptu: _iptuController.text.trim().isEmpty
            ? null
            : Masks.unmaskMoney(_iptuController.text) / 100.0,
        features: _selectedFeatures.isEmpty ? null : _selectedFeatures,
      );

      final response = await _aiService.generatePropertyDescription(request);

      if (mounted) {
        if (response.success && response.data != null) {
          setState(() {
            _titleController.text = response.data!.title;
            _descriptionController.text = response.data!.description;
            _generatedVariants.add(response.data!);
          });
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text('Descrição gerada com sucesso!')),
          );
        } else {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text(response.message ?? 'Erro ao gerar descrição'),
              backgroundColor: AppColors.status.error,
            ),
          );
        }
      }
    } catch (e) {
      debugPrint('Erro ao gerar descrição: $e');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Erro ao gerar descrição')),
        );
      }
    } finally {
      if (mounted) {
        setState(() {
          _isGeneratingDescription = false;
        });
      }
    }
  }

  bool _canAdvanceToNextStep() {
    // Verifica se pode avançar sem mostrar mensagens de erro
    switch (_currentStep) {
      case 0: // Etapa 1: Informações Básicas
        // Título e descrição só são obrigatórios se a IA estiver desativada
        if (!_autoGenerateOnReview) {
          if (_titleController.text.trim().isEmpty ||
              _titleController.text.trim().length < 3) {
            return false;
          }
          if (_descriptionController.text.trim().isEmpty ||
              _descriptionController.text.trim().length < 10) {
            return false;
          }
        }
        return true;

      case 1: // Etapa 2: Localização
        if (_streetController.text.trim().isEmpty ||
            _numberController.text.trim().isEmpty ||
            _neighborhoodController.text.trim().isEmpty ||
            _cityController.text.trim().isEmpty ||
            _stateController.text.trim().isEmpty ||
            _stateController.text.trim().length != 2) {
          return false;
        }
        final cep = _zipCodeController.text.replaceAll(RegExp(r'[^0-9]'), '');
        if (cep.isEmpty || cep.length != 8) {
          return false;
        }
        return true;

      case 2: // Etapa 3: Características
        if (_totalAreaController.text.trim().isEmpty) {
          return false;
        }
        final totalArea = double.tryParse(_totalAreaController.text);
        if (totalArea == null || totalArea <= 0) {
          return false;
        }
        // Validar área construída se preenchida
        if (_builtAreaController.text.trim().isNotEmpty) {
          final builtArea = double.tryParse(_builtAreaController.text);
          if (builtArea != null && builtArea > totalArea) {
            return false;
          }
        }
        return true;

      case 3: // Etapa 4: Valores
        // Se aceita negociação, deve ter preço mínimo de venda OU aluguel
        if (_acceptsNegotiation) {
          final hasSalePrice = _salePriceController.text.trim().isNotEmpty;
          final hasRentPrice = _rentPriceController.text.trim().isNotEmpty;
          final hasMinSalePrice = _minSalePriceController.text
              .trim()
              .isNotEmpty;
          final hasMinRentPrice = _minRentPriceController.text
              .trim()
              .isNotEmpty;

          if (hasSalePrice && !hasMinSalePrice) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: const Text(
                  'Ao aceitar negociação, é obrigatório informar o preço mínimo de venda quando há preço de venda',
                ),
                backgroundColor: AppColors.status.error,
              ),
            );
            return false;
          }

          if (hasRentPrice && !hasMinRentPrice) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: const Text(
                  'Ao aceitar negociação, é obrigatório informar o preço mínimo de aluguel quando há preço de aluguel',
                ),
                backgroundColor: AppColors.status.error,
              ),
            );
            return false;
          }
        }
        return true;

      case 4: // Etapa 5: Galeria
        final totalImages = _selectedImages.length + _uploadedImages.length;
        if (totalImages < 5) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text(
                'É necessário adicionar no mínimo 5 imagens. Você adicionou $totalImages de 5.',
              ),
              backgroundColor: AppColors.status.error,
            ),
          );
          return false;
        }
        return true;

      case 5: // Etapa 6: Clientes e Proprietário
        if (_ownerNameController.text.trim().isEmpty ||
            _ownerEmailController.text.trim().isEmpty ||
            !_ownerEmailController.text.contains('@') ||
            !_ownerEmailController.text.contains('.') ||
            _ownerPhoneController.text.trim().isEmpty ||
            _ownerDocumentController.text.trim().isEmpty ||
            _ownerAddressController.text.trim().isEmpty) {
          return false;
        }
        return true;

      case 6: // Etapa 7: Revisão (não pode avançar, é a última)
        return false;

      default:
        return true;
    }
  }

  bool _validateCurrentStep() {
    switch (_currentStep) {
      case 0: // Etapa 1: Informações Básicas
        // Título e descrição só são obrigatórios se a IA estiver desativada
        if (!_autoGenerateOnReview) {
          if (_titleController.text.trim().isEmpty) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: const Text(
                  'Por favor, preencha o título ou ative a geração automática com IA',
                ),
                backgroundColor: AppColors.status.error,
              ),
            );
            return false;
          }
          if (_titleController.text.trim().length < 3) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: const Text('Título deve ter pelo menos 3 caracteres'),
                backgroundColor: AppColors.status.error,
              ),
            );
            return false;
          }
          if (_descriptionController.text.trim().isEmpty) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: const Text(
                  'Por favor, preencha a descrição ou ative a geração automática com IA',
                ),
                backgroundColor: AppColors.status.error,
              ),
            );
            return false;
          }
          if (_descriptionController.text.trim().length < 10) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: const Text(
                  'Descrição deve ter pelo menos 10 caracteres',
                ),
                backgroundColor: AppColors.status.error,
              ),
            );
            return false;
          }
        }
        return true;

      case 1: // Etapa 2: Localização
        if (_streetController.text.trim().isEmpty) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: const Text('Por favor, preencha a rua'),
              backgroundColor: AppColors.status.error,
            ),
          );
          return false;
        }
        if (_numberController.text.trim().isEmpty) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: const Text('Por favor, preencha o número'),
              backgroundColor: AppColors.status.error,
            ),
          );
          return false;
        }
        if (_neighborhoodController.text.trim().isEmpty) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: const Text('Por favor, preencha o bairro'),
              backgroundColor: AppColors.status.error,
            ),
          );
          return false;
        }
        if (_cityController.text.trim().isEmpty) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: const Text('Por favor, preencha a cidade'),
              backgroundColor: AppColors.status.error,
            ),
          );
          return false;
        }
        if (_stateController.text.trim().isEmpty ||
            _stateController.text.trim().length != 2) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: const Text(
                'Por favor, preencha o estado (UF) com 2 letras',
              ),
              backgroundColor: AppColors.status.error,
            ),
          );
          return false;
        }
        final cep = _zipCodeController.text.replaceAll(RegExp(r'[^0-9]'), '');
        if (cep.isEmpty || cep.length != 8) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: const Text(
                'Por favor, preencha um CEP válido (8 dígitos)',
              ),
              backgroundColor: AppColors.status.error,
            ),
          );
          return false;
        }
        return true;

      case 2: // Etapa 3: Características
        if (_totalAreaController.text.trim().isEmpty) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: const Text('Por favor, preencha a área total'),
              backgroundColor: AppColors.status.error,
            ),
          );
          return false;
        }
        final totalArea = double.tryParse(_totalAreaController.text);
        if (totalArea == null || totalArea <= 0) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: const Text('Área total deve ser maior que zero'),
              backgroundColor: AppColors.status.error,
            ),
          );
          return false;
        }
        // Validar área construída se preenchida
        if (_builtAreaController.text.trim().isNotEmpty) {
          final builtArea = double.tryParse(_builtAreaController.text);
          if (builtArea != null && builtArea > totalArea) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: const Text(
                  'Área construída não pode ser maior que área total',
                ),
                backgroundColor: AppColors.status.error,
              ),
            );
            return false;
          }
        }
        return true;

      case 3: // Etapa 4: Valores
        // Se aceita negociação, deve ter preço mínimo de venda OU aluguel
        if (_acceptsNegotiation) {
          final hasSalePrice = _salePriceController.text.trim().isNotEmpty;
          final hasRentPrice = _rentPriceController.text.trim().isNotEmpty;
          final hasMinSalePrice = _minSalePriceController.text
              .trim()
              .isNotEmpty;
          final hasMinRentPrice = _minRentPriceController.text
              .trim()
              .isNotEmpty;

          if (hasSalePrice && !hasMinSalePrice) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: const Text(
                  'Ao aceitar negociação, é obrigatório informar o preço mínimo de venda quando há preço de venda',
                ),
                backgroundColor: AppColors.status.error,
              ),
            );
            return false;
          }

          if (hasRentPrice && !hasMinRentPrice) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: const Text(
                  'Ao aceitar negociação, é obrigatório informar o preço mínimo de aluguel quando há preço de aluguel',
                ),
                backgroundColor: AppColors.status.error,
              ),
            );
            return false;
          }
        }
        return true;

      case 4: // Etapa 5: Galeria
        final totalImages = _selectedImages.length + _uploadedImages.length;
        if (totalImages < 5) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text(
                'É necessário adicionar no mínimo 5 imagens. Você adicionou $totalImages de 5.',
              ),
              backgroundColor: AppColors.status.error,
            ),
          );
          return false;
        }
        return true;

      case 5: // Etapa 6: Clientes e Proprietário
        if (_ownerNameController.text.trim().isEmpty) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: const Text('Por favor, preencha o nome do proprietário'),
              backgroundColor: AppColors.status.error,
            ),
          );
          return false;
        }
        if (_ownerEmailController.text.trim().isEmpty) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: const Text(
                'Por favor, preencha o email do proprietário',
              ),
              backgroundColor: AppColors.status.error,
            ),
          );
          return false;
        }
        if (!_ownerEmailController.text.contains('@') ||
            !_ownerEmailController.text.contains('.')) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: const Text('Por favor, preencha um email válido'),
              backgroundColor: AppColors.status.error,
            ),
          );
          return false;
        }
        if (_ownerPhoneController.text.trim().isEmpty) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: const Text(
                'Por favor, preencha o telefone do proprietário',
              ),
              backgroundColor: AppColors.status.error,
            ),
          );
          return false;
        }
        if (_ownerDocumentController.text.trim().isEmpty) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: const Text(
                'Por favor, preencha o CPF/CNPJ do proprietário',
              ),
              backgroundColor: AppColors.status.error,
            ),
          );
          return false;
        }
        if (_ownerAddressController.text.trim().isEmpty) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: const Text(
                'Por favor, preencha o endereço do proprietário',
              ),
              backgroundColor: AppColors.status.error,
            ),
          );
          return false;
        }
        return true;

      case 6: // Etapa 7: Revisão
        // Validar título e descrição na revisão (sempre obrigatórios na revisão)
        if (_titleController.text.trim().isEmpty) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: const Text(
                'Por favor, preencha o título ou gere com IA',
              ),
              backgroundColor: AppColors.status.error,
            ),
          );
          return false;
        }
        if (_titleController.text.trim().length < 3) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: const Text('Título deve ter pelo menos 3 caracteres'),
              backgroundColor: AppColors.status.error,
            ),
          );
          return false;
        }
        if (_descriptionController.text.trim().isEmpty) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: const Text(
                'Por favor, preencha a descrição ou gere com IA',
              ),
              backgroundColor: AppColors.status.error,
            ),
          );
          return false;
        }
        if (_descriptionController.text.trim().length < 10) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: const Text(
                'Descrição deve ter pelo menos 10 caracteres',
              ),
              backgroundColor: AppColors.status.error,
            ),
          );
          return false;
        }
        return true;

      default:
        return true;
    }
  }

  void _nextStep() {
    // Validar etapa atual antes de avançar
    if (!_validateCurrentStep()) {
      return; // Não avança se houver erro
    }

    if (_currentStep < _totalSteps - 1) {
      final nextStep = _currentStep + 1;
      _pageController.nextPage(
        duration: const Duration(milliseconds: 300),
        curve: Curves.easeInOut,
      );
      setState(() {
        _currentStep = nextStep;
      });

      // Se chegou na etapa de revisão e auto-geração está ativada, gerar automaticamente
      if (nextStep == 6 &&
          _autoGenerateOnReview &&
          !_hasAutoGeneratedOnReview) {
        _autoGenerateDescriptionOnReview();
      }
    }
  }

  Future<void> _autoGenerateDescriptionOnReview() async {
    // Valida campos mínimos
    if (_totalAreaController.text.trim().isEmpty ||
        _cityController.text.trim().isEmpty) {
      return; // Não gera se não tiver dados mínimos
    }

    setState(() {
      _hasAutoGeneratedOnReview = true;
      _isGeneratingDescription = true;
    });

    try {
      final request = GenerateDescriptionRequest(
        type: _selectedType.value,
        city: _cityController.text.trim(),
        neighborhood: _neighborhoodController.text.trim().isEmpty
            ? null
            : _neighborhoodController.text.trim(),
        totalArea: double.tryParse(_totalAreaController.text) ?? 0.0,
        builtArea: _builtAreaController.text.trim().isEmpty
            ? null
            : double.tryParse(_builtAreaController.text),
        bedrooms: _bedroomsController.text.trim().isEmpty
            ? null
            : int.tryParse(_bedroomsController.text),
        bathrooms: _bathroomsController.text.trim().isEmpty
            ? null
            : int.tryParse(_bathroomsController.text),
        parkingSpaces: _parkingSpacesController.text.trim().isEmpty
            ? null
            : int.tryParse(_parkingSpacesController.text),
        salePrice: _salePriceController.text.trim().isEmpty
            ? null
            : Masks.unmaskMoney(_salePriceController.text) / 100.0,
        rentPrice: _rentPriceController.text.trim().isEmpty
            ? null
            : Masks.unmaskMoney(_rentPriceController.text) / 100.0,
        condominiumFee: _condominiumFeeController.text.trim().isEmpty
            ? null
            : Masks.unmaskMoney(_condominiumFeeController.text) / 100.0,
        iptu: _iptuController.text.trim().isEmpty
            ? null
            : Masks.unmaskMoney(_iptuController.text) / 100.0,
        features: _selectedFeatures.isEmpty ? null : _selectedFeatures,
      );

      final response = await _aiService.generatePropertyDescription(request);

      if (mounted) {
        if (response.success && response.data != null) {
          setState(() {
            // Só preenche se os campos estiverem vazios
            if (_titleController.text.trim().isEmpty) {
              _titleController.text = response.data!.title;
            }
            if (_descriptionController.text.trim().isEmpty) {
              _descriptionController.text = response.data!.description;
            }
            _generatedVariants.add(response.data!);
          });
        }
      }
    } catch (e) {
      debugPrint('Erro ao gerar descrição automaticamente: $e');
    } finally {
      if (mounted) {
        setState(() {
          _isGeneratingDescription = false;
        });
      }
    }
  }

  void _previousStep() {
    if (_currentStep > 0) {
      _pageController.previousPage(
        duration: const Duration(milliseconds: 300),
        curve: Curves.easeInOut,
      );
      setState(() {
        _currentStep--;
      });
    }
  }

  Future<void> _saveProperty() async {
    if (!_formKey.currentState!.validate()) {
      // Voltar para a primeira etapa com erro
      _pageController.jumpToPage(0);
      setState(() {
        _currentStep = 0;
      });
      return;
    }

    setState(() {
      _isLoading = true;
    });

    try {
      final data = <String, dynamic>{
        'title': _titleController.text.trim(),
        'description': _descriptionController.text.trim(),
        'type': _selectedType.value,
        'status': _selectedStatus.value,
        'street': _streetController.text.trim(),
        'number': _numberController.text.trim(),
        if (_complementController.text.trim().isNotEmpty)
          'complement': _complementController.text.trim(),
        'neighborhood': _neighborhoodController.text.trim(),
        'city': _cityController.text.trim(),
        'state': _stateController.text.trim(),
        'zipCode': _zipCodeController.text.trim(),
        'totalArea': double.tryParse(_totalAreaController.text) ?? 0.0,
        if (_builtAreaController.text.trim().isNotEmpty)
          'builtArea': double.tryParse(_builtAreaController.text),
        if (_bedroomsController.text.trim().isNotEmpty)
          'bedrooms': int.tryParse(_bedroomsController.text),
        if (_bathroomsController.text.trim().isNotEmpty)
          'bathrooms': int.tryParse(_bathroomsController.text),
        if (_parkingSpacesController.text.trim().isNotEmpty)
          'parkingSpaces': int.tryParse(_parkingSpacesController.text),
        if (_salePriceController.text.trim().isNotEmpty)
          'salePrice': Masks.unmaskMoney(_salePriceController.text) / 100.0,
        if (_rentPriceController.text.trim().isNotEmpty)
          'rentPrice': Masks.unmaskMoney(_rentPriceController.text) / 100.0,
        if (_condominiumFeeController.text.trim().isNotEmpty)
          'condominiumFee':
              Masks.unmaskMoney(_condominiumFeeController.text) / 100.0,
        if (_iptuController.text.trim().isNotEmpty)
          'iptu': Masks.unmaskMoney(_iptuController.text) / 100.0,
        'features': _selectedFeatures,
        'acceptsNegotiation': _acceptsNegotiation,
        if (_minSalePriceController.text.trim().isNotEmpty)
          'minSalePrice':
              Masks.unmaskMoney(_minSalePriceController.text) / 100.0,
        if (_minRentPriceController.text.trim().isNotEmpty)
          'minRentPrice':
              Masks.unmaskMoney(_minRentPriceController.text) / 100.0,
        if (_offerBelowMinSaleAction != null)
          'offerBelowMinSaleAction': _offerBelowMinSaleAction,
        if (_offerBelowMinRentAction != null)
          'offerBelowMinRentAction': _offerBelowMinRentAction,
        // Proprietário (obrigatórios)
        'ownerName': _ownerNameController.text.trim(),
        'ownerEmail': _ownerEmailController.text.trim(),
        'ownerPhone': _ownerPhoneController.text.trim(),
        'ownerDocument': _ownerDocumentController.text.trim(),
        'ownerAddress': _ownerAddressController.text.trim(),
      };

      final response = widget.propertyId != null
          ? await _propertyService.updateProperty(widget.propertyId!, data)
          : await _propertyService.createProperty(data);

      if (mounted) {
        if (response.success && response.data != null) {
          // Fazer upload das imagens se houver
          if (_selectedImages.isNotEmpty) {
            await _uploadImages(response.data!.id);
          }

          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text(
                widget.propertyId != null
                    ? 'Propriedade atualizada com sucesso!'
                    : 'Propriedade criada com sucesso!',
              ),
              backgroundColor: AppColors.status.success,
            ),
          );
          Navigator.of(context).pop(true);
        } else {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text(response.message ?? 'Erro ao salvar propriedade'),
              backgroundColor: AppColors.status.error,
            ),
          );
        }
      }
    } catch (e) {
      debugPrint('Erro ao salvar propriedade: $e');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: const Text('Erro ao conectar com o servidor'),
            backgroundColor: AppColors.status.error,
          ),
        );
      }
    } finally {
      if (mounted) {
        setState(() {
          _isLoading = false;
        });
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    if (_isLoadingProperty) {
      return AppScaffold(
        title: widget.propertyId != null ? 'Editar Imóvel' : 'Novo Imóvel',
        body: _buildSkeleton(context, theme),
      );
    }

    return AppScaffold(
      title: widget.propertyId != null ? 'Editar Imóvel' : 'Novo Imóvel',
      body: Form(
        key: _formKey,
        child: Column(
          children: [
            // Indicador de progresso
            _buildStepIndicator(theme),

            // Conteúdo das etapas
            Expanded(
              child: PageView(
                controller: _pageController,
                physics: const NeverScrollableScrollPhysics(),
                children: [
                  _buildStep1BasicInfo(theme),
                  _buildStep2Location(theme),
                  _buildStep3Characteristics(theme),
                  _buildStep4Values(theme),
                  _buildStep5Gallery(theme),
                  _buildStep6Clients(theme),
                  _buildStep7Review(theme),
                ],
              ),
            ),

            // Botões de navegação
            _buildNavigationButtons(theme),
          ],
        ),
      ),
    );
  }

  Widget _buildStepIndicator(ThemeData theme) {
    return Container(
      padding: const EdgeInsets.all(20),
      child: Row(
        children: List.generate(_totalSteps, (index) {
          final isActive = index == _currentStep;
          final isCompleted = index < _currentStep;

          return Expanded(
            child: Row(
              children: [
                Expanded(
                  child: Container(
                    height: 4,
                    decoration: BoxDecoration(
                      color: isCompleted || isActive
                          ? AppColors.primary.primary
                          : ThemeHelpers.borderColor(context),
                      borderRadius: BorderRadius.circular(2),
                    ),
                  ),
                ),
                if (index < _totalSteps - 1) const SizedBox(width: 8),
              ],
            ),
          );
        }),
      ),
    );
  }

  Widget _buildStep1BasicInfo(ThemeData theme) {
    return SingleChildScrollView(
      padding: const EdgeInsets.all(20),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            'Informações Básicas',
            style: theme.textTheme.headlineSmall?.copyWith(
              fontWeight: FontWeight.bold,
            ),
          ),
          const SizedBox(height: 24),

          // Toggle para auto-geração com IA
          Card(
            child: Padding(
              padding: const EdgeInsets.all(16),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Row(
                    children: [
                      Icon(
                        Icons.auto_awesome,
                        color: _autoGenerateOnReview
                            ? AppColors.primary.primary
                            : ThemeHelpers.textSecondaryColor(context),
                        size: 20,
                      ),
                      const SizedBox(width: 8),
                      Expanded(
                        child: Text(
                          'Gerar título e descrição com IA',
                          style: theme.textTheme.bodyLarge?.copyWith(
                            fontWeight: FontWeight.w600,
                          ),
                        ),
                      ),
                      const SizedBox(width: 12),
                      Switch(
                        value: _autoGenerateOnReview,
                        onChanged: (value) {
                          setState(() {
                            _autoGenerateOnReview = value;
                            // Se desativar a IA e os campos estiverem vazios, limpar
                            if (!value) {
                              // Não limpa, apenas força revalidação
                            }
                          });
                        },
                      ),
                    ],
                  ),
                  const SizedBox(height: 8),
                  Text(
                    _autoGenerateOnReview
                        ? 'A IA gerará automaticamente na etapa de revisão usando todos os dados preenchidos'
                        : 'Você precisará preencher manualmente ou gerar na etapa de revisão',
                    style: theme.textTheme.bodySmall?.copyWith(
                      color: ThemeHelpers.textSecondaryColor(context),
                    ),
                  ),
                ],
              ),
            ),
          ),
          const SizedBox(height: 24),

          CustomTextField(
            controller: _titleController,
            label: _autoGenerateOnReview ? 'Título' : 'Título *',
            hint: 'Ex: Casa com 3 quartos em condomínio fechado',
            validator: (value) {
              // Só valida se a IA estiver desativada
              if (!_autoGenerateOnReview) {
                if (value == null || value.trim().isEmpty) {
                  return 'Título é obrigatório ou ative a geração automática com IA';
                }
                if (value.trim().length < 3) {
                  return 'Título deve ter pelo menos 3 caracteres';
                }
                if (value.trim().length > 255) {
                  return 'Título deve ter no máximo 255 caracteres';
                }
              } else {
                // Se a IA estiver ativada, só valida se o usuário preencher manualmente
                if (value != null && value.trim().isNotEmpty) {
                  if (value.trim().length < 3) {
                    return 'Título deve ter pelo menos 3 caracteres';
                  }
                  if (value.trim().length > 255) {
                    return 'Título deve ter no máximo 255 caracteres';
                  }
                }
              }
              return null;
            },
          ),
          const SizedBox(height: 16),

          CustomTextField(
            controller: _descriptionController,
            label: _autoGenerateOnReview ? 'Descrição' : 'Descrição *',
            hint: 'Descreva o imóvel em detalhes...',
            maxLines: 6,
            validator: (value) {
              // Só valida se a IA estiver desativada
              if (!_autoGenerateOnReview) {
                if (value == null || value.trim().isEmpty) {
                  return 'Descrição é obrigatória ou ative a geração automática com IA';
                }
                if (value.trim().length < 10) {
                  return 'Descrição deve ter pelo menos 10 caracteres';
                }
                if (value.trim().length > 5000) {
                  return 'Descrição deve ter no máximo 5000 caracteres';
                }
              } else {
                // Se a IA estiver ativada, só valida se o usuário preencher manualmente
                if (value != null && value.trim().isNotEmpty) {
                  if (value.trim().length < 10) {
                    return 'Descrição deve ter pelo menos 10 caracteres';
                  }
                  if (value.trim().length > 5000) {
                    return 'Descrição deve ter no máximo 5000 caracteres';
                  }
                }
              }
              return null;
            },
          ),
          const SizedBox(height: 24),

          Text('Tipo de Imóvel *', style: theme.textTheme.titleMedium),
          const SizedBox(height: 8),
          Wrap(
            spacing: 12,
            runSpacing: 12,
            children: PropertyType.values.map((type) {
              final isSelected = _selectedType == type;
              return ChoiceChip(
                label: Text(type.label),
                selected: isSelected,
                onSelected: (selected) {
                  if (selected) {
                    setState(() {
                      _selectedType = type;
                    });
                  }
                },
              );
            }).toList(),
          ),
          const SizedBox(height: 24),

          Text('Status', style: theme.textTheme.titleMedium),
          const SizedBox(height: 8),
          Wrap(
            spacing: 12,
            runSpacing: 12,
            children: PropertyStatus.values.map((status) {
              final isSelected = _selectedStatus == status;
              return ChoiceChip(
                label: Text(status.label),
                selected: isSelected,
                onSelected: (selected) {
                  if (selected) {
                    setState(() {
                      _selectedStatus = status;
                    });
                  }
                },
              );
            }).toList(),
          ),
        ],
      ),
    );
  }

  Widget _buildStep2Location(ThemeData theme) {
    return SingleChildScrollView(
      padding: const EdgeInsets.all(20),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            'Localização',
            style: theme.textTheme.headlineSmall?.copyWith(
              fontWeight: FontWeight.bold,
            ),
          ),
          const SizedBox(height: 24),

          // CEP - Fullwidth com texto informativo
          CustomTextField(
            controller: _zipCodeController,
            label: 'CEP *',
            hint: '00000-000',
            keyboardType: TextInputType.number,
            inputFormatters: [CepInputFormatter()],
            validator: (value) {
              if (value == null || value.trim().isEmpty) {
                return 'CEP é obrigatório';
              }
              final cep = value.replaceAll(RegExp(r'[^0-9]'), '');
              if (cep.length != 8) {
                return 'CEP deve ter 8 dígitos';
              }
              return null;
            },
            suffixIcon: IconButton(
              icon: const Icon(Icons.search),
              onPressed: _searchCep,
              tooltip: 'Buscar CEP',
            ),
          ),
          const SizedBox(height: 8),
          Container(
            padding: const EdgeInsets.all(12),
            decoration: BoxDecoration(
              color: AppColors.primary.primary.withOpacity(0.1),
              borderRadius: BorderRadius.circular(8),
              border: Border.all(
                color: AppColors.primary.primary.withOpacity(0.3),
              ),
            ),
            child: Row(
              children: [
                Icon(
                  Icons.info_outline,
                  size: 18,
                  color: AppColors.primary.primary,
                ),
                const SizedBox(width: 8),
                Expanded(
                  child: Text(
                    'Ao preencher o CEP, os demais campos serão preenchidos automaticamente',
                    style: theme.textTheme.bodySmall?.copyWith(
                      color: AppColors.primary.primary,
                    ),
                  ),
                ),
              ],
            ),
          ),
          const SizedBox(height: 24),

          // Rua e Número
          Row(
            children: [
              Expanded(
                flex: 3,
                child: CustomTextField(
                  controller: _streetController,
                  label: 'Rua *',
                  hint: 'Nome da rua',
                  validator: (value) {
                    if (value == null || value.trim().isEmpty) {
                      return 'Rua é obrigatória';
                    }
                    if (value.trim().length < 2) {
                      return 'Rua deve ter pelo menos 2 caracteres';
                    }
                    return null;
                  },
                ),
              ),
              const SizedBox(width: 12),
              Expanded(
                flex: 1,
                child: CustomTextField(
                  controller: _numberController,
                  label: 'Número *',
                  hint: '123',
                  validator: (value) {
                    if (value == null || value.trim().isEmpty) {
                      return 'Número é obrigatório';
                    }
                    if (value.trim().length < 1) {
                      return 'Número é obrigatório';
                    }
                    return null;
                  },
                ),
              ),
            ],
          ),
          const SizedBox(height: 16),

          // Complemento - Fullwidth
          CustomTextField(
            controller: _complementController,
            label: 'Complemento',
            hint: 'Apartamento, bloco, etc.',
          ),
          const SizedBox(height: 16),

          // Bairro - Fullwidth
          CustomTextField(
            controller: _neighborhoodController,
            label: 'Bairro *',
            hint: 'Nome do bairro',
            validator: (value) {
              if (value == null || value.trim().isEmpty) {
                return 'Bairro é obrigatório';
              }
              if (value.trim().length < 2) {
                return 'Bairro deve ter pelo menos 2 caracteres';
              }
              if (value.trim().length > 100) {
                return 'Bairro deve ter no máximo 100 caracteres';
              }
              return null;
            },
          ),
          const SizedBox(height: 16),

          // Cidade e Estado
          Row(
            children: [
              Expanded(
                flex: 2,
                child: CustomTextField(
                  controller: _cityController,
                  label: 'Cidade *',
                  hint: 'Nome da cidade',
                  validator: (value) {
                    if (value == null || value.trim().isEmpty) {
                      return 'Cidade é obrigatória';
                    }
                    if (value.trim().length < 2) {
                      return 'Cidade deve ter pelo menos 2 caracteres';
                    }
                    if (value.trim().length > 100) {
                      return 'Cidade deve ter no máximo 100 caracteres';
                    }
                    return null;
                  },
                ),
              ),
              const SizedBox(width: 12),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      'Estado *',
                      style: theme.textTheme.labelLarge?.copyWith(
                        fontWeight: FontWeight.w600,
                      ),
                    ),
                    const SizedBox(height: 8),
                    TextFormField(
                      controller: _stateController,
                      maxLength: 2,
                      textCapitalization: TextCapitalization.characters,
                      decoration: InputDecoration(
                        hintText: 'UF',
                        counterText: '', // Ocultar contador de caracteres
                        border: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(12),
                        ),
                      ),
                      validator: (value) {
                        if (value == null || value.trim().isEmpty) {
                          return 'Estado é obrigatório';
                        }
                        if (value.trim().length != 2) {
                          return 'Digite 2 letras';
                        }
                        return null;
                      },
                    ),
                  ],
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }

  Widget _buildStep3Characteristics(ThemeData theme) {
    return SingleChildScrollView(
      padding: const EdgeInsets.all(20),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            'Características',
            style: theme.textTheme.headlineSmall?.copyWith(
              fontWeight: FontWeight.bold,
            ),
          ),
          const SizedBox(height: 24),

          Row(
            children: [
              Expanded(
                child: _buildFormField(
                  theme,
                  controller: _totalAreaController,
                  label: 'Área Total (m²) *',
                  hint: '0.0',
                  keyboardType: const TextInputType.numberWithOptions(
                    decimal: true,
                  ),
                  inputFormatters: [
                    FilteringTextInputFormatter.allow(
                      RegExp(r'^\d+\.?\d{0,2}'),
                    ),
                  ],
                  validator: (value) {
                    if (value == null || value.trim().isEmpty) {
                      return 'Área total é obrigatória';
                    }
                    final area = double.tryParse(value);
                    if (area == null || area <= 0) {
                      return 'Área deve ser maior que zero';
                    }
                    if (area >= 1000000) {
                      return 'Área total deve ser menor que 1.000.000 m²';
                    }
                    return null;
                  },
                ),
              ),
              const SizedBox(width: 12),
              Expanded(
                child: _buildFormField(
                  theme,
                  controller: _builtAreaController,
                  label: 'Área Construída (m²)',
                  hint: '0.0',
                  keyboardType: const TextInputType.numberWithOptions(
                    decimal: true,
                  ),
                  inputFormatters: [
                    FilteringTextInputFormatter.allow(
                      RegExp(r'^\d+\.?\d{0,2}'),
                    ),
                  ],
                  validator: (value) {
                    if (value != null && value.trim().isNotEmpty) {
                      final area = double.tryParse(value);
                      if (area != null) {
                        if (area <= 0) {
                          return 'Área construída deve ser positiva';
                        }
                        if (area >= 1000000) {
                          return 'Área construída deve ser menor que 1.000.000 m²';
                        }
                        // Validar se não é maior que área total
                        final totalArea = double.tryParse(
                          _totalAreaController.text,
                        );
                        if (totalArea != null && area > totalArea) {
                          return 'Área construída não pode ser maior que área total';
                        }
                      }
                    }
                    return null;
                  },
                ),
              ),
            ],
          ),
          const SizedBox(height: 16),

          Row(
            children: [
              Expanded(
                child: _buildFormField(
                  theme,
                  controller: _bedroomsController,
                  label: 'Quartos',
                  hint: '0',
                  keyboardType: TextInputType.number,
                  inputFormatters: [FilteringTextInputFormatter.digitsOnly],
                  validator: (value) {
                    if (value != null && value.trim().isNotEmpty) {
                      final bedrooms = int.tryParse(value);
                      if (bedrooms != null && bedrooms < 0) {
                        return 'Número de quartos não pode ser negativo';
                      }
                      if (bedrooms != null && bedrooms >= 50) {
                        return 'Número de quartos deve ser menor que 50';
                      }
                    }
                    return null;
                  },
                ),
              ),
              const SizedBox(width: 12),
              Expanded(
                child: _buildFormField(
                  theme,
                  controller: _bathroomsController,
                  label: 'Banheiros',
                  hint: '0',
                  keyboardType: TextInputType.number,
                  inputFormatters: [FilteringTextInputFormatter.digitsOnly],
                  validator: (value) {
                    if (value != null && value.trim().isNotEmpty) {
                      final bathrooms = int.tryParse(value);
                      if (bathrooms != null && bathrooms < 0) {
                        return 'Número de banheiros não pode ser negativo';
                      }
                      if (bathrooms != null && bathrooms >= 20) {
                        return 'Número de banheiros deve ser menor que 20';
                      }
                    }
                    return null;
                  },
                ),
              ),
              const SizedBox(width: 12),
              Expanded(
                child: _buildFormField(
                  theme,
                  controller: _parkingSpacesController,
                  label: 'Vagas',
                  hint: '0',
                  keyboardType: TextInputType.number,
                  inputFormatters: [FilteringTextInputFormatter.digitsOnly],
                  validator: (value) {
                    if (value != null && value.trim().isNotEmpty) {
                      final parking = int.tryParse(value);
                      if (parking != null && parking < 0) {
                        return 'Número de vagas não pode ser negativo';
                      }
                      if (parking != null && parking >= 20) {
                        return 'Número de vagas deve ser menor que 20';
                      }
                    }
                    return null;
                  },
                ),
              ),
            ],
          ),
          const SizedBox(height: 24),

          Text('Recursos do Imóvel', style: theme.textTheme.titleMedium),
          const SizedBox(height: 12),
          Wrap(
            spacing: 8,
            runSpacing: 8,
            children:
                [
                  'Ar condicionado',
                  'Aquecimento',
                  'Elevador',
                  'Portaria 24h',
                  'Segurança 24h',
                  'Piscina',
                  'Academia',
                  'Playground',
                  'Churrasqueira',
                  'Área gourmet',
                  'Jardim',
                  'Terraço',
                  'Varanda',
                  'Sacada',
                  'Vista para o mar',
                  'Vista para a montanha',
                  'Próximo ao metrô',
                  'Próximo a escolas',
                  'Próximo a hospitais',
                  'Próximo a shopping',
                  'Garagem coberta',
                  'Garagem descoberta',
                  'Depósito',
                  'Lavanderia',
                  'Closet',
                  'Home office',
                  'Lareira',
                  'Sistema de alarme',
                  'Câmeras de segurança',
                  'Interfone',
                  'Antena parabólica',
                  'TV a cabo',
                  'Internet',
                  'Gás encanado',
                  'Água quente',
                  'Energia solar',
                  'Mobiliado',
                  'Semi-mobiliado',
                  'Pronto para morar',
                  'Em construção',
                  'Novo',
                  'Usado',
                ].map((feature) {
                  final isSelected = _selectedFeatures.contains(feature);
                  return FilterChip(
                    label: Text(feature),
                    selected: isSelected,
                    onSelected: (selected) {
                      setState(() {
                        if (selected) {
                          _selectedFeatures.add(feature);
                        } else {
                          _selectedFeatures.remove(feature);
                        }
                      });
                    },
                  );
                }).toList(),
          ),
        ],
      ),
    );
  }

  Widget _buildStep4Values(ThemeData theme) {
    return SingleChildScrollView(
      padding: const EdgeInsets.all(20),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            'Valores',
            style: theme.textTheme.headlineSmall?.copyWith(
              fontWeight: FontWeight.bold,
            ),
          ),
          const SizedBox(height: 24),

          Row(
            children: [
              Expanded(
                child: _buildFormField(
                  theme,
                  controller: _salePriceController,
                  label: 'Preço de Venda',
                  hint: 'R\$ 0,00',
                  keyboardType: TextInputType.number,
                  inputFormatters: [MoneyInputFormatter()],
                  validator: (value) {
                    if (value != null && value.trim().isNotEmpty) {
                      final price = Masks.unmaskMoney(value) / 100.0;
                      if (price <= 0) {
                        return 'Preço de venda deve ser positivo';
                      }
                      if (price >= 1000000000) {
                        return 'Preço de venda deve ser menor que R\$ 1 bilhão';
                      }
                    }
                    return null;
                  },
                ),
              ),
              const SizedBox(width: 12),
              Expanded(
                child: _buildFormField(
                  theme,
                  controller: _rentPriceController,
                  label: 'Preço de Aluguel',
                  hint: 'R\$ 0,00',
                  keyboardType: TextInputType.number,
                  inputFormatters: [MoneyInputFormatter()],
                  validator: (value) {
                    if (value != null && value.trim().isNotEmpty) {
                      final price = Masks.unmaskMoney(value) / 100.0;
                      if (price <= 0) {
                        return 'Preço de aluguel deve ser positivo';
                      }
                      if (price >= 1000000) {
                        return 'Preço de aluguel deve ser menor que R\$ 1 milhão';
                      }
                    }
                    return null;
                  },
                ),
              ),
            ],
          ),
          const SizedBox(height: 16),

          Row(
            children: [
              Expanded(
                child: _buildFormField(
                  theme,
                  controller: _condominiumFeeController,
                  label: 'Condomínio',
                  hint: 'R\$ 0,00',
                  keyboardType: TextInputType.number,
                  inputFormatters: [MoneyInputFormatter()],
                  validator: (value) {
                    if (value != null && value.trim().isNotEmpty) {
                      final fee = Masks.unmaskMoney(value) / 100.0;
                      if (fee <= 0) {
                        return 'Valor do condomínio deve ser positivo';
                      }
                      if (fee >= 100000) {
                        return 'Valor do condomínio deve ser menor que R\$ 100 mil';
                      }
                    }
                    return null;
                  },
                ),
              ),
              const SizedBox(width: 12),
              Expanded(
                child: _buildFormField(
                  theme,
                  controller: _iptuController,
                  label: 'IPTU',
                  hint: 'R\$ 0,00',
                  keyboardType: TextInputType.number,
                  inputFormatters: [MoneyInputFormatter()],
                  validator: (value) {
                    if (value != null && value.trim().isNotEmpty) {
                      final iptu = Masks.unmaskMoney(value) / 100.0;
                      if (iptu <= 0) {
                        return 'IPTU deve ser positivo';
                      }
                      if (iptu >= 100000) {
                        return 'IPTU deve ser menor que R\$ 100 mil';
                      }
                    }
                    return null;
                  },
                ),
              ),
            ],
          ),
          const SizedBox(height: 24),

          SwitchListTile(
            title: const Text('Aceita Negociação'),
            subtitle: const Text('Permite ofertas abaixo do preço mínimo'),
            value: _acceptsNegotiation,
            onChanged: (value) {
              setState(() {
                _acceptsNegotiation = value;
              });
            },
          ),
          if (_acceptsNegotiation) ...[
            const SizedBox(height: 16),
            Row(
              children: [
                Expanded(
                  child: _buildFormField(
                    theme,
                    controller: _minSalePriceController,
                    label: 'Preço Mínimo de Venda',
                    hint: 'R\$ 0,00',
                    keyboardType: TextInputType.number,
                    inputFormatters: [MoneyInputFormatter()],
                    validator: (value) {
                      // Se aceita negociação e tem preço de venda, o mínimo é obrigatório
                      final salePriceText = _salePriceController.text.trim();
                      if (salePriceText.isNotEmpty) {
                        if (value == null || value.trim().isEmpty) {
                          return 'Preço mínimo de venda é obrigatório quando aceita negociação';
                        }
                        final minPrice = Masks.unmaskMoney(value) / 100.0;
                        if (minPrice <= 0) {
                          return 'Preço mínimo deve ser positivo';
                        }
                        final salePrice =
                            Masks.unmaskMoney(salePriceText) / 100.0;
                        if (minPrice >= salePrice) {
                          return 'Preço mínimo deve ser menor que preço de venda';
                        }
                      }
                      // Se preencheu, valida formato
                      if (value != null && value.trim().isNotEmpty) {
                        final minPrice = Masks.unmaskMoney(value) / 100.0;
                        if (minPrice <= 0) {
                          return 'Preço mínimo deve ser positivo';
                        }
                      }
                      return null;
                    },
                  ),
                ),
                const SizedBox(width: 12),
                Expanded(
                  child: _buildFormField(
                    theme,
                    controller: _minRentPriceController,
                    label: 'Preço Mínimo de Aluguel',
                    hint: 'R\$ 0,00',
                    keyboardType: TextInputType.number,
                    inputFormatters: [MoneyInputFormatter()],
                    validator: (value) {
                      // Se aceita negociação e tem preço de aluguel, o mínimo é obrigatório
                      final rentPriceText = _rentPriceController.text.trim();
                      if (rentPriceText.isNotEmpty) {
                        if (value == null || value.trim().isEmpty) {
                          return 'Preço mínimo de aluguel é obrigatório quando aceita negociação';
                        }
                        final minPrice = Masks.unmaskMoney(value) / 100.0;
                        if (minPrice <= 0) {
                          return 'Preço mínimo deve ser positivo';
                        }
                        final rentPrice =
                            Masks.unmaskMoney(rentPriceText) / 100.0;
                        if (minPrice >= rentPrice) {
                          return 'Preço mínimo deve ser menor que preço de aluguel';
                        }
                      }
                      // Se preencheu, valida formato
                      if (value != null && value.trim().isNotEmpty) {
                        final minPrice = Masks.unmaskMoney(value) / 100.0;
                        if (minPrice <= 0) {
                          return 'Preço mínimo deve ser positivo';
                        }
                      }
                      return null;
                    },
                  ),
                ),
              ],
            ),
            const SizedBox(height: 16),
            Text(
              'Ação para ofertas abaixo do mínimo',
              style: theme.textTheme.titleSmall,
            ),
            const SizedBox(height: 8),
            Row(
              children: [
                Expanded(
                  child: DropdownButtonFormField<String>(
                    initialValue: _offerBelowMinSaleAction,
                    decoration: InputDecoration(
                      labelText: 'Venda',
                      border: OutlineInputBorder(
                        borderRadius: BorderRadius.circular(8),
                      ),
                    ),
                    items: const [
                      DropdownMenuItem(
                        value: 'reject',
                        child: Text('Rejeitar'),
                      ),
                      DropdownMenuItem(
                        value: 'pending',
                        child: Text('Pendente'),
                      ),
                      DropdownMenuItem(
                        value: 'notify',
                        child: Text('Notificar'),
                      ),
                    ],
                    onChanged: (value) {
                      setState(() {
                        _offerBelowMinSaleAction = value;
                      });
                    },
                  ),
                ),
                const SizedBox(width: 12),
                Expanded(
                  child: DropdownButtonFormField<String>(
                    initialValue: _offerBelowMinRentAction,
                    decoration: InputDecoration(
                      labelText: 'Aluguel',
                      border: OutlineInputBorder(
                        borderRadius: BorderRadius.circular(8),
                      ),
                    ),
                    items: const [
                      DropdownMenuItem(
                        value: 'reject',
                        child: Text('Rejeitar'),
                      ),
                      DropdownMenuItem(
                        value: 'pending',
                        child: Text('Pendente'),
                      ),
                      DropdownMenuItem(
                        value: 'notify',
                        child: Text('Notificar'),
                      ),
                    ],
                    onChanged: (value) {
                      setState(() {
                        _offerBelowMinRentAction = value;
                      });
                    },
                  ),
                ),
              ],
            ),
          ],
        ],
      ),
    );
  }

  Widget _buildStep5Gallery(ThemeData theme) {
    return SingleChildScrollView(
      padding: const EdgeInsets.all(20),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Text(
                'Galeria de Imagens',
                style: theme.textTheme.headlineSmall?.copyWith(
                  fontWeight: FontWeight.bold,
                ),
              ),
              Container(
                padding: const EdgeInsets.symmetric(
                  horizontal: 12,
                  vertical: 6,
                ),
                decoration: BoxDecoration(
                  color: (_selectedImages.length + _uploadedImages.length) >= 5
                      ? AppColors.status.success.withOpacity(0.1)
                      : AppColors.status.warning.withOpacity(0.1),
                  borderRadius: BorderRadius.circular(20),
                  border: Border.all(
                    color:
                        (_selectedImages.length + _uploadedImages.length) >= 5
                        ? AppColors.status.success
                        : AppColors.status.warning,
                    width: 1,
                  ),
                ),
                child: Text(
                  '${_selectedImages.length + _uploadedImages.length}/5 imagens',
                  style: theme.textTheme.bodySmall?.copyWith(
                    color:
                        (_selectedImages.length + _uploadedImages.length) >= 5
                        ? AppColors.status.success
                        : AppColors.status.warning,
                    fontWeight: FontWeight.w600,
                  ),
                ),
              ),
            ],
          ),
          if ((_selectedImages.length + _uploadedImages.length) < 5) ...[
            const SizedBox(height: 8),
            Container(
              padding: const EdgeInsets.all(12),
              decoration: BoxDecoration(
                color: AppColors.status.warning.withOpacity(0.1),
                borderRadius: BorderRadius.circular(8),
                border: Border.all(
                  color: AppColors.status.warning.withOpacity(0.3),
                ),
              ),
              child: Row(
                children: [
                  Icon(
                    Icons.info_outline,
                    size: 18,
                    color: AppColors.status.warning,
                  ),
                  const SizedBox(width: 8),
                  Expanded(
                    child: Text(
                      'É necessário adicionar no mínimo 5 imagens para continuar',
                      style: theme.textTheme.bodySmall?.copyWith(
                        color: AppColors.status.warning,
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ],
          const SizedBox(height: 24),

          Row(
            children: [
              Expanded(
                child: OutlinedButton.icon(
                  onPressed: _isUploadingImages ? null : _pickImages,
                  icon: _isUploadingImages
                      ? const SizedBox(
                          width: 20,
                          height: 20,
                          child: CircularProgressIndicator(strokeWidth: 2),
                        )
                      : const Icon(Icons.photo_library),
                  label: Text(_isUploadingImages ? 'Enviando...' : 'Galeria'),
                ),
              ),
              const SizedBox(width: 12),
              Expanded(
                child: OutlinedButton.icon(
                  onPressed: _isUploadingImages
                      ? null
                      : () async {
                          try {
                            final XFile? photo = await _imagePicker.pickImage(
                              source: ImageSource.camera,
                              imageQuality: 85,
                            );
                            if (photo != null && mounted) {
                              setState(() {
                                _selectedImages.add(File(photo.path));
                              });
                            }
                          } catch (e) {
                            if (mounted) {
                              ScaffoldMessenger.of(context).showSnackBar(
                                SnackBar(
                                  content: Text('Erro ao tirar foto: $e'),
                                  backgroundColor: AppColors.status.error,
                                ),
                              );
                            }
                          }
                        },
                  icon: const Icon(Icons.camera_alt),
                  label: const Text('Tirar Foto'),
                ),
              ),
            ],
          ),
          const SizedBox(height: 16),

          if (_selectedImages.isEmpty && _uploadedImages.isEmpty)
            Container(
              width: double.infinity,
              padding: const EdgeInsets.all(40),
              decoration: BoxDecoration(
                border: Border.all(color: ThemeHelpers.borderColor(context)),
                borderRadius: BorderRadius.circular(12),
              ),
              child: Column(
                children: [
                  Icon(
                    Icons.image_outlined,
                    size: 48,
                    color: ThemeHelpers.textSecondaryColor(context),
                  ),
                  const SizedBox(height: 12),
                  Text(
                    'Nenhuma imagem adicionada',
                    style: theme.textTheme.bodyMedium?.copyWith(
                      color: ThemeHelpers.textSecondaryColor(context),
                    ),
                  ),
                ],
              ),
            )
          else
            GridView.builder(
              shrinkWrap: true,
              physics: const NeverScrollableScrollPhysics(),
              gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
                crossAxisCount: 3,
                crossAxisSpacing: 8,
                mainAxisSpacing: 8,
              ),
              itemCount: _selectedImages.length + _uploadedImages.length,
              itemBuilder: (context, index) {
                if (index < _selectedImages.length) {
                  // Imagem selecionada (ainda não enviada)
                  return Stack(
                    children: [
                      ClipRRect(
                        borderRadius: BorderRadius.circular(8),
                        child: Image.file(
                          _selectedImages[index],
                          fit: BoxFit.cover,
                          width: double.infinity,
                          height: double.infinity,
                        ),
                      ),
                      Positioned(
                        top: 4,
                        right: 4,
                        child: IconButton(
                          icon: const Icon(Icons.close, size: 20),
                          color: Colors.white,
                          style: IconButton.styleFrom(
                            backgroundColor: Colors.black54,
                            padding: const EdgeInsets.all(4),
                          ),
                          onPressed: () {
                            setState(() {
                              _selectedImages.removeAt(index);
                            });
                          },
                        ),
                      ),
                    ],
                  );
                } else {
                  // Imagem já enviada
                  final imageIndex = index - _selectedImages.length;
                  final image = _uploadedImages[imageIndex];
                  return Stack(
                    children: [
                      ClipRRect(
                        borderRadius: BorderRadius.circular(8),
                        child: ShimmerImage(
                          imageUrl: image.url,
                          fit: BoxFit.cover,
                          width: double.infinity,
                          height: double.infinity,
                          borderRadius: BorderRadius.circular(8),
                        ),
                      ),
                      if (image.isMain)
                        Positioned(
                          top: 4,
                          left: 4,
                          child: Container(
                            padding: const EdgeInsets.symmetric(
                              horizontal: 6,
                              vertical: 2,
                            ),
                            decoration: BoxDecoration(
                              color: AppColors.primary.primary,
                              borderRadius: BorderRadius.circular(4),
                            ),
                            child: Text(
                              'Principal',
                              style: theme.textTheme.bodySmall?.copyWith(
                                color: Colors.white,
                                fontSize: 10,
                              ),
                            ),
                          ),
                        ),
                      Positioned(
                        top: 4,
                        right: 4,
                        child: IconButton(
                          icon: const Icon(Icons.close, size: 20),
                          color: Colors.white,
                          style: IconButton.styleFrom(
                            backgroundColor: Colors.black54,
                            padding: const EdgeInsets.all(4),
                          ),
                          onPressed: () async {
                            final response = await _galleryService.deleteImage(
                              image.id,
                            );
                            if (mounted) {
                              if (response.success) {
                                setState(() {
                                  _uploadedImages.removeAt(imageIndex);
                                });
                              } else {
                                ScaffoldMessenger.of(context).showSnackBar(
                                  SnackBar(
                                    content: Text(
                                      response.message ??
                                          'Erro ao remover imagem',
                                    ),
                                    backgroundColor: AppColors.status.error,
                                  ),
                                );
                              }
                            }
                          },
                        ),
                      ),
                    ],
                  );
                }
              },
            ),
        ],
      ),
    );
  }

  Widget _buildStep6Clients(ThemeData theme) {
    return SingleChildScrollView(
      padding: const EdgeInsets.all(20),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            'Proprietário',
            style: theme.textTheme.headlineSmall?.copyWith(
              fontWeight: FontWeight.bold,
            ),
          ),
          const SizedBox(height: 8),
          Text(
            'Informações obrigatórias do proprietário',
            style: theme.textTheme.bodyMedium?.copyWith(
              color: ThemeHelpers.textSecondaryColor(context),
            ),
          ),
          const SizedBox(height: 24),

          CustomTextField(
            controller: _ownerNameController,
            label: 'Nome do Proprietário *',
            hint: 'Nome completo',
            validator: (value) {
              if (value == null || value.trim().isEmpty) {
                return 'Nome do proprietário é obrigatório';
              }
              if (value.trim().length < 3) {
                return 'Nome deve ter pelo menos 3 caracteres';
              }
              return null;
            },
          ),
          const SizedBox(height: 16),

          CustomTextField(
            controller: _ownerEmailController,
            label: 'Email do Proprietário *',
            hint: 'email@exemplo.com',
            keyboardType: TextInputType.emailAddress,
            validator: (value) {
              if (value == null || value.trim().isEmpty) {
                return 'Email do proprietário é obrigatório';
              }
              if (!value.contains('@') || !value.contains('.')) {
                return 'Email inválido';
              }
              return null;
            },
          ),
          const SizedBox(height: 16),

          CustomTextField(
            controller: _ownerPhoneController,
            label: 'Telefone do Proprietário *',
            hint: '(00) 00000-0000',
            keyboardType: TextInputType.phone,
            validator: (value) {
              if (value == null || value.trim().isEmpty) {
                return 'Telefone do proprietário é obrigatório';
              }
              if (value.trim().length < 10) {
                return 'Telefone deve ter pelo menos 10 caracteres';
              }
              return null;
            },
          ),
          const SizedBox(height: 16),

          CustomTextField(
            controller: _ownerDocumentController,
            label: 'CPF/CNPJ do Proprietário *',
            hint: '000.000.000-00 ou 00.000.000/0000-00',
            validator: (value) {
              if (value == null || value.trim().isEmpty) {
                return 'CPF/CNPJ do proprietário é obrigatório';
              }
              if (value.trim().length < 11) {
                return 'CPF/CNPJ deve ter pelo menos 11 caracteres';
              }
              return null;
            },
          ),
          const SizedBox(height: 16),

          CustomTextField(
            controller: _ownerAddressController,
            label: 'Endereço do Proprietário *',
            hint: 'Endereço completo',
            maxLines: 2,
            validator: (value) {
              if (value == null || value.trim().isEmpty) {
                return 'Endereço do proprietário é obrigatório';
              }
              if (value.trim().length < 10) {
                return 'Endereço deve ter pelo menos 10 caracteres';
              }
              return null;
            },
          ),
          const SizedBox(height: 32),

          Text(
            'Clientes Interessados',
            style: theme.textTheme.headlineSmall?.copyWith(
              fontWeight: FontWeight.bold,
            ),
          ),
          const SizedBox(height: 8),
          Text(
            'Opcional - você pode adicionar clientes depois',
            style: theme.textTheme.bodyMedium?.copyWith(
              color: ThemeHelpers.textSecondaryColor(context),
            ),
          ),
          const SizedBox(height: 16),

          OutlinedButton.icon(
            onPressed: () {
              // TODO: Implementar seleção de clientes
              ScaffoldMessenger.of(context).showSnackBar(
                const SnackBar(content: Text('Seleção de clientes em breve')),
              );
            },
            icon: const Icon(Icons.person_add),
            label: const Text('Adicionar Clientes'),
          ),
          const SizedBox(height: 16),

          if (_selectedClientIds.isEmpty)
            Container(
              width: double.infinity,
              padding: const EdgeInsets.all(40),
              decoration: BoxDecoration(
                border: Border.all(color: ThemeHelpers.borderColor(context)),
                borderRadius: BorderRadius.circular(12),
              ),
              child: Column(
                children: [
                  Icon(
                    Icons.people_outline,
                    size: 48,
                    color: ThemeHelpers.textSecondaryColor(context),
                  ),
                  const SizedBox(height: 12),
                  Text(
                    'Nenhum cliente adicionado',
                    style: theme.textTheme.bodyMedium?.copyWith(
                      color: ThemeHelpers.textSecondaryColor(context),
                    ),
                  ),
                  const SizedBox(height: 4),
                  Text(
                    'Você pode adicionar clientes depois',
                    style: theme.textTheme.bodySmall?.copyWith(
                      color: ThemeHelpers.textSecondaryColor(context),
                    ),
                  ),
                ],
              ),
            ),
        ],
      ),
    );
  }

  Widget _buildStep7Review(ThemeData theme) {
    return SingleChildScrollView(
      padding: const EdgeInsets.all(20),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            'Revisão e Geração com IA',
            style: theme.textTheme.headlineSmall?.copyWith(
              fontWeight: FontWeight.bold,
            ),
          ),
          const SizedBox(height: 8),
          Text(
            'Revise os dados e gere automaticamente título e descrição com IA',
            style: theme.textTheme.bodyMedium?.copyWith(
              color: ThemeHelpers.textSecondaryColor(context),
            ),
          ),
          const SizedBox(height: 24),

          // Botão para gerar manualmente
          SizedBox(
            width: double.infinity,
            child: ElevatedButton.icon(
              onPressed: _isGeneratingDescription ? null : _generateDescription,
              icon: _isGeneratingDescription
                  ? const SizedBox(
                      width: 20,
                      height: 20,
                      child: CircularProgressIndicator(strokeWidth: 2),
                    )
                  : const Icon(Icons.auto_awesome),
              label: Text(
                _isGeneratingDescription
                    ? 'Gerando...'
                    : 'Gerar Descrição com IA',
              ),
              style: ElevatedButton.styleFrom(
                padding: const EdgeInsets.symmetric(vertical: 16),
              ),
            ),
          ),
          const SizedBox(height: 24),

          // Campos de título e descrição editáveis
          CustomTextField(
            controller: _titleController,
            label: 'Título *',
            hint: 'Ex: Casa com 3 quartos em condomínio fechado',
            validator: (value) {
              if (value == null || value.trim().isEmpty) {
                return 'Título é obrigatório';
              }
              if (value.trim().length < 3) {
                return 'Título deve ter pelo menos 3 caracteres';
              }
              if (value.trim().length > 255) {
                return 'Título deve ter no máximo 255 caracteres';
              }
              return null;
            },
          ),
          const SizedBox(height: 16),

          CustomTextField(
            controller: _descriptionController,
            label: 'Descrição *',
            hint: 'Descreva o imóvel em detalhes...',
            maxLines: 8,
            validator: (value) {
              if (value == null || value.trim().isEmpty) {
                return 'Descrição é obrigatória';
              }
              if (value.trim().length < 10) {
                return 'Descrição deve ter pelo menos 10 caracteres';
              }
              if (value.trim().length > 5000) {
                return 'Descrição deve ter no máximo 5000 caracteres';
              }
              return null;
            },
          ),
          const SizedBox(height: 24),

          // Resumo dos dados
          Text(
            'Resumo dos Dados',
            style: theme.textTheme.titleLarge?.copyWith(
              fontWeight: FontWeight.bold,
            ),
          ),
          const SizedBox(height: 16),

          _buildReviewCard(theme, 'Tipo', _selectedType.label),
          const SizedBox(height: 8),
          _buildReviewCard(theme, 'Status', _selectedStatus.label),
          const SizedBox(height: 8),
          _buildReviewCard(
            theme,
            'Localização',
            '${_streetController.text}, ${_numberController.text} - ${_neighborhoodController.text}, ${_cityController.text} - ${_stateController.text}',
          ),
          const SizedBox(height: 8),
          _buildReviewCard(
            theme,
            'Área Total',
            '${_totalAreaController.text} m²',
          ),
          if (_builtAreaController.text.isNotEmpty) ...[
            const SizedBox(height: 8),
            _buildReviewCard(
              theme,
              'Área Construída',
              '${_builtAreaController.text} m²',
            ),
          ],
          if (_bedroomsController.text.isNotEmpty) ...[
            const SizedBox(height: 8),
            _buildReviewCard(theme, 'Quartos', _bedroomsController.text),
          ],
          if (_bathroomsController.text.isNotEmpty) ...[
            const SizedBox(height: 8),
            _buildReviewCard(theme, 'Banheiros', _bathroomsController.text),
          ],
          if (_salePriceController.text.isNotEmpty) ...[
            const SizedBox(height: 8),
            _buildReviewCard(
              theme,
              'Preço de Venda',
              'R\$ ${_salePriceController.text}',
            ),
          ],
          if (_rentPriceController.text.isNotEmpty) ...[
            const SizedBox(height: 8),
            _buildReviewCard(
              theme,
              'Preço de Aluguel',
              'R\$ ${_rentPriceController.text}',
            ),
          ],
        ],
      ),
    );
  }

  Widget _buildReviewCard(ThemeData theme, String label, String value) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(12),
        child: Row(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Expanded(
              flex: 2,
              child: Text(
                label,
                style: theme.textTheme.bodyMedium?.copyWith(
                  fontWeight: FontWeight.w600,
                  color: ThemeHelpers.textSecondaryColor(context),
                ),
              ),
            ),
            Expanded(
              flex: 3,
              child: Text(value, style: theme.textTheme.bodyMedium),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildFormField(
    ThemeData theme, {
    required TextEditingController controller,
    String? label,
    String? hint,
    TextInputType? keyboardType,
    String? Function(String?)? validator,
    int? maxLength,
    TextCapitalization? textCapitalization,
    List<TextInputFormatter>? inputFormatters,
    String? prefixText,
    Widget? suffix,
  }) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        if (label != null) ...[
          Text(
            label,
            style: theme.textTheme.labelLarge?.copyWith(
              fontWeight: FontWeight.w600,
            ),
          ),
          const SizedBox(height: 8),
        ],
        TextFormField(
          controller: controller,
          keyboardType: keyboardType,
          validator: validator,
          maxLength: maxLength,
          textCapitalization: textCapitalization ?? TextCapitalization.none,
          inputFormatters: inputFormatters,
          style: theme.textTheme.bodyLarge?.copyWith(
            color: theme.colorScheme.onSurface,
          ),
          decoration: InputDecoration(
            hintText: hint,
            hintStyle: theme.textTheme.bodyLarge?.copyWith(
              color: theme.colorScheme.onSurface.withValues(alpha: 0.6),
            ),
            prefixText: prefixText,
            suffixIcon: suffix,
            counterText:
                '', // Ocultar contador de caracteres para não desalinhar
          ),
        ),
      ],
    );
  }

  Widget _buildNavigationButtons(ThemeData theme) {
    return Container(
      padding: const EdgeInsets.all(20),
      decoration: BoxDecoration(
        color: ThemeHelpers.cardBackgroundColor(context),
        border: Border(
          top: BorderSide(color: ThemeHelpers.borderColor(context)),
        ),
      ),
      child: SafeArea(
        child: Row(
          children: [
            if (_currentStep > 0)
              Expanded(
                child: OutlinedButton(
                  onPressed: _previousStep,
                  child: const Text('Voltar'),
                ),
              ),
            if (_currentStep > 0) const SizedBox(width: 12),
            Expanded(
              flex: 2,
              child: _currentStep < _totalSteps - 1
                  ? CustomButton(
                      text: 'Próximo',
                      onPressed: _canAdvanceToNextStep() ? _nextStep : null,
                      icon: Icons.arrow_forward,
                    )
                  : CustomButton(
                      text: widget.propertyId != null
                          ? 'Salvar'
                          : 'Criar Propriedade',
                      onPressed: _isLoading ? null : _saveProperty,
                      isLoading: _isLoading,
                      icon: Icons.check,
                    ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildSkeleton(BuildContext context, ThemeData theme) {
    return Column(
      children: [
        // Skeleton do indicador de etapas
        Container(
          padding: const EdgeInsets.all(20),
          child: Row(
            children: List.generate(_totalSteps, (index) {
              return Expanded(
                child: Row(
                  children: [
                    Expanded(
                      child: SkeletonBox(
                        height: 4,
                        borderRadius: 2,
                        margin: EdgeInsets.only(
                          right: index < _totalSteps - 1 ? 8 : 0,
                        ),
                      ),
                    ),
                    if (index < _totalSteps - 1)
                      SkeletonBox(
                        width: 24,
                        height: 24,
                        borderRadius: 12,
                        margin: const EdgeInsets.symmetric(horizontal: 4),
                      ),
                  ],
                ),
              );
            }),
          ),
        ),

        // Skeleton do conteúdo do formulário
        Expanded(
          child: SingleChildScrollView(
            padding: const EdgeInsets.all(20),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                // Skeleton do título da etapa
                SkeletonText(
                  width: 200,
                  height: 24,
                  margin: const EdgeInsets.only(bottom: 24),
                ),

                // Skeleton dos campos de entrada
                SkeletonText(
                  width: double.infinity,
                  height: 16,
                  margin: const EdgeInsets.only(bottom: 8),
                ),
                SkeletonBox(
                  width: double.infinity,
                  height: 56,
                  borderRadius: 8,
                  margin: const EdgeInsets.only(bottom: 16),
                ),

                SkeletonText(
                  width: double.infinity,
                  height: 16,
                  margin: const EdgeInsets.only(bottom: 8),
                ),
                SkeletonBox(
                  width: double.infinity,
                  height: 120,
                  borderRadius: 8,
                  margin: const EdgeInsets.only(bottom: 16),
                ),

                // Skeleton de campos em linha
                Row(
                  children: [
                    Expanded(
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          SkeletonText(
                            width: 100,
                            height: 16,
                            margin: const EdgeInsets.only(bottom: 8),
                          ),
                          SkeletonBox(
                            width: double.infinity,
                            height: 56,
                            borderRadius: 8,
                            margin: const EdgeInsets.only(bottom: 16),
                          ),
                        ],
                      ),
                    ),
                    const SizedBox(width: 12),
                    Expanded(
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          SkeletonText(
                            width: 100,
                            height: 16,
                            margin: const EdgeInsets.only(bottom: 8),
                          ),
                          SkeletonBox(
                            width: double.infinity,
                            height: 56,
                            borderRadius: 8,
                            margin: const EdgeInsets.only(bottom: 16),
                          ),
                        ],
                      ),
                    ),
                  ],
                ),

                // Skeleton de chips (tipo de imóvel, status, etc)
                SkeletonText(
                  width: 150,
                  height: 16,
                  margin: const EdgeInsets.only(bottom: 8, top: 8),
                ),
                Wrap(
                  spacing: 12,
                  runSpacing: 12,
                  children: List.generate(4, (index) {
                    return SkeletonBox(
                      width: 100,
                      height: 32,
                      borderRadius: 16,
                    );
                  }),
                ),

                const SizedBox(height: 24),

                // Skeleton de mais campos
                SkeletonText(
                  width: double.infinity,
                  height: 16,
                  margin: const EdgeInsets.only(bottom: 8),
                ),
                SkeletonBox(
                  width: double.infinity,
                  height: 56,
                  borderRadius: 8,
                  margin: const EdgeInsets.only(bottom: 16),
                ),

                SkeletonText(
                  width: double.infinity,
                  height: 16,
                  margin: const EdgeInsets.only(bottom: 8),
                ),
                SkeletonBox(
                  width: double.infinity,
                  height: 56,
                  borderRadius: 8,
                  margin: const EdgeInsets.only(bottom: 16),
                ),
              ],
            ),
          ),
        ),

        // Skeleton dos botões de navegação
        Container(
          padding: const EdgeInsets.all(20),
          decoration: BoxDecoration(
            color: ThemeHelpers.cardBackgroundColor(context),
            border: Border(
              top: BorderSide(color: ThemeHelpers.borderColor(context)),
            ),
          ),
          child: SafeArea(
            child: Row(
              children: [
                Expanded(child: SkeletonBox(height: 48, borderRadius: 8)),
                const SizedBox(width: 12),
                Expanded(
                  flex: 2,
                  child: SkeletonBox(height: 48, borderRadius: 8),
                ),
              ],
            ),
          ),
        ),
      ],
    );
  }
}
